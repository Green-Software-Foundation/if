# `if-attest`

`if-attest` allows users to "attest" to a manifest using a cryptographic signature and then either save the attestation locally or post it attestation to a public blockchain so it is available forever.

The concept is as follows:

1) User receives a computed manifest file
2) User wants to verify the manifest is correct. If it is, attest to it.
3) `if-attest` runs `if-check` over the given manifest.
4) If `if-check` is sucessful, `if-attest` grabs summary information from the manifest and computes the manifest hash (a string of bytes that can *only* be generated by hashing that precise file)
5) `if-attest` compiles all the manifest information into an attestation object, optionally connects to the chosen blockchain, signs the attestation and sends it in a transaction to store it onchain. Altewrnatively, the attestation is created and saved locally as a .txt file.
6) Anyone can then look up an onchain attestation to see that some specific attester (e.g. GSF, some trusted auditor) has attested to its validity. You can selectively share your offchain attestation, and its signature can still be verified by anyone.


## Why is an attestation valuable?

Only the holder of the private key can possibly sign with the given signature. Anyone can recover the public key associated with a signature to be sure it was really the named attester who sent the transaction. It also creates an immutabnle snapshot of your manifest details. The manifest details inclue an adit level from 1-5 that the signer is attesting, effectively using their private key to confirm that the manifest meets some predefined level of quality. In doing so, they are effectively staking some reputation on the veracity of the data. Every private key is associated with a public key/address that should be shared by the attester, linking their signatures to their real world identity.

You can think of an attestation as a trust token - it represents some amount of staked reputation that you as an end user can use to make your own judgments about how trustworthy a manifest is. For example, maybe you don;t trust a manifest because some of the data is redacted. What if the manifest provider exposed the redacted data to a trusted third party under an NDA who then re-executed the manifest with all the original raw data and attested that the SCI score and total carbon were correct? What about if they attested at a level that meant that they fully audited the input data, including independently observing the target system themselves? What if that attester was the GSF? Or an audit firm? Or a government agency? What if ten diverse attesters all attested to the data? Each attestation is a token of additional trustworthiness. There might not be a firm boundary between trustworthy and untrustworthy, just like there's no fixed amount of money that makes separates rich or not rich, but attestations are signals that accumulate up to form a trust picture for a given manifest.


## What is actually attested to?

The following information is included in an attestation:

```
'start': the first timestamp captured by the manifest
'end': the last timestamp captured by the manifest
'hash': the unique keccak256 hash for the manifest file
'if': the IF version used to compute the manifest
'verified': true.false showing that `if-check` returned a success response
'sci': the computes SCI score, always in gCO2e/fnctional unit
'energy: the aggregated energy value for the manifest in kWh
'carbon': the aggregated carbon value for the manifest in gCO2eq
'level': the audit level being attested to
'quality': the data quality score at defined here: https://wayback.archive-it.org/12090/20230313054137/https://ec.europa.eu/environment/archives/eussd/pdf/footprint/PEF%20methodology%20final%20draft.pdf (not currently implemented)
'functionalUnit': the functional unit used to calculate the SCI
```

The attestation does not guarantee that the **input data** is correct - there's not much we can do in the event that a manifest provider is deliberately falsifying or accidentally providing incorrect measurements. We won't have access to the systems being measured - to verify the validity of measurements feeding a manifest can only really be done by third party auditors with access to the systems under measurement.

`if-attest` assumes the input data is correct and algorithmically verifies that the given output data really resulted from honestly executing the given input data using the configuration and plugin options defined in the given manifest. There's also the `levels` field that gives auditors the option to do deeper audits offchain, e.g. manually checking a user's systems or collaborating on plugin choice, advising on config etc. and capturing this by assigning a higher audit level.

e.g. you might define something like:

```
level-0: only checks manifest executes correctly
level-1: checks plugin choices conform to best practises
level-3: all config conforms to best practises
level-4: underlying code indepedently reviewed and tested
level-5: measurements independently verified by attester
```

In today's implementation we do not provide strict guidance on what the audit levels mean. This requires a trust framework to be established and codified. We leave this as an open question that can be discussed, formalized as a standard and mapped on to this codebase later.

No sensitive information is included in an attestation - it is all summary information and hashes. This means an organization can choose to selectively disclose to trusted third parties without also sharing freely. The third party can always hash the given file to see that the attested file was identical to the one they were given.

You could also design a system where an attestation includes a link to another attestation, for example attesting to a deeper audit or an attestation by a third party.

## How to use `if-attest`

`if-attest` makes use of some cryptography libraries built for Ethereum. This means an Ethereum key pair is needed. The key pair is commonly referred to as an `account`. It comprises a private key (64 hex characters, 32 bytes) and a public key (128 hex characters, 64 bytes). The Ethereum address is a 40 hex character string resulting from applying the Keccak-256 hash function to the public key and selecting the last 40 characters. The address is prefixed with `0x` to indicate that it is hex encoded.


### Create an Ethereum account

You can easily create an account using a consumer Ethereum wallet (such as Metamask), an Ethereum client (e.g. go-ethereum) or a developer library such as `ethers` or `web3js`, both for Javascript. 

Here's an example of creating an Ethereum account by randomyl geenrating a private key, then deriving a public key and address from it, using `ethersjs`:

```sh
npm i ethers
```

```js
var ethers = require('ethers');  
var crypto = require('crypto');

var id = crypto.randomBytes(32).toString('hex');
var privateKey = "0x"+id;
console.log("SAVE BUT DO NOT SHARE THIS:", privateKey);

var wallet = new ethers.Wallet(privateKey);
console.log("Address: " + wallet.address);
```

Make sure you make a safe copy of the private key, because we will need it to run `if-attest`. It should be added to your environment variables as `ETH_PRIVATE_KEY`. If you are an Ethereum user with actual funds, please use a compeltely new, separate, fresh address that's completely isolated from your real account!

You will also need to keep a copy of your address, because you can share this publicly so people can verify that data you sign with your private key was really signed by you. In extremis, you can regenerate your public key and address from your private key, but you can't go the other way!

We are using these Ethereum tools to do our signing and attesting, so you need to create these assets even if you are going to do all your attestations locally and never touch a blockchain.


> **Creating an Ethereum account is free and can be kept entirely local to your machine - it is just a pair of keys. You can do this without ever interacting with Ethereum itself** 

>Whatever your opinions on crypto, one of the things it has given the world is easier access and richer tooling over private key cryptography.  We're using it here for an application that's entirely non-financial, but benefits from accessible cryptography and the ability to post to a public, immutable database in the form of a public blockchain.

If you already have an Ethereum account, you can import it - but please make sure it is a throwaway developer account, not one that you use for anything money-related! Also, never, never, NEVER NEVER push your private key to a Github repository. make sure `.gitignore` contains `.env` and check every time you push that your private key isn't leaked anywhere in your commits. There are bots continually scanning github for leaked keys - if you ever accidentally push your keys, assume they are instantly compromised and abandon that account forever. Once `if-attest` is beyond the protoype stage we'll ship some tooling to prevent the key from ever having to be in environment variables.


## Attestations

Attestations are just snippets of data that conform to some predefined schema and are signed by a private key. They can then be stored locally, shared via your own network (post them on your website, if you wish) or posted to a public blockchain.

We are using the [Ethereum Attestation Service](https://attest.org/) to bootstrap our attestations. They have deployed the attestation smart contracts on Ethereum and many other associated blockchains, such as layer 2's and testnets. Layer 2's are cheaper, faster blockchains that settle to the main Ethereum blockchain periodically. Testnets are blockchains that use tokens of no real world value and are typically used to test smart contracts befor they are deployed on a "real" network.

Here's an example of a raw attestation. If you run `if-attest` configured to create local attestations, you'll get a text file that looks like this:

```
{"sig":{"version":2,"uid":"0x047d38b6d175fe8a36a597863b7d8d94939aa2fd4b4f19831229c95f5eda5604","domain":{"name":"EAS Attestation","version":"0.26","chainId":"11155111","verifyingContract":"0xC2679fBD37d54388Ce493F1DB75320D236e1815e"},"primaryType":"Attest","message":{"version":2,"recipient":"0xc8317137B5c511ef9CE1762CE498FE16950EF42d","expirationTime":"0","time":"1729173300","revocable":true,"schema":"0x11fdca810433efc2d5b9fe8305b39669e8d0feb81f699a767fe48ce26fcf6a6c","refUID":"0x0000000000000000000000000000000000000000000000000000000000000000","data":"0x000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a020d034e94040bf5b40ff76f9568155cacbc7ed0d488a8fcea8dc37bd24b0d0dd00000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000f0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000010323032332d30382d30365430303a3030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010323032332d30382d30365430303a3030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005302e372e30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b736974652d766973697473000000000000000000000000000000000000000000","salt":"0x0951f85ad71286a55562608cfba8cad023820a78cce8fd5df2a1498af0812505"},"types":{"Attest":[{"name":"version","type":"uint16"},{"name":"schema","type":"bytes32"},{"name":"recipient","type":"address"},{"name":"time","type":"uint64"},{"name":"expirationTime","type":"uint64"},{"name":"revocable","type":"bool"},{"name":"refUID","type":"bytes32"},{"name":"data","type":"bytes"},{"name":"salt","type":"bytes32"}]},"signature":{"v":27,"r":"0xea4ac79da011dd364b69cfb45cce6e9b5d71444861d0bb44456d7e50f433f981","s":"0x4106232e9af816c465657e10d39612c958f5b6f552d637c9cff5469ee7634333"}}, "signer":"0xc8317137B5c511ef9CE1762CE498FE16950EF42d"}
```

OK, it's not super human readable. This is because the manifest data is hex-encoded. Everything you need to verify the signatuire and recover the manifest summary data is here.


## Onchain vs offchain attestations

Having created an attestation, you cna chose to post it to a blockchain or to store it "offchain". Offchain can mean storing it in your own database, storing it on some decentralized storage platform such as IPFS, or archived locally. They are just signed pieces of data.

Pushing the attestation to a public blockchain has some benefits. First, you do not have to store and serve the data yourself. You know that your attestation will always be avcailable to any one, any time, and a network of blockchain node operators bear the cost of maintainign the network - you are outsourcing your server maintenance to them and you know anyone can access your attestation from anywhere, any time. Second, it's a good way to signal to the world that you are committed to sharing your data - once it's on the blockchain, you can't take it down, hide it, amend it or decide to be selective about who you share it with.

Offchain attestations allow you more flexibility about what you share and when and with whom. The attestation itelf is identical to the one you would post on the blockchain, but you have control over public access to it. There might be business, security, legal or privacy reasons you might want to keep your attestations off the public blockchain. We have tried to make the attestations as privacy preserving and comapct as possible to encourage more open sharing of attestations.


## Choice of blockchain

`if-attest` v1 will use the Sepolia testnet. It is designed to be a testnet for Ethereum mainnet, targeting smart contract developers rather than client developers. It's convenient because it's easy to get Sepolia ETH to cover gas costs and it's stable and supported for the long term. later, we might decide the `if-attest` stack needs to be migrated to a "live" blockchain, but Sepolia serves our needs for now.

## Connecting to the blockchain

We're using Infura for convenience, but you can adjust this to use your own private Ethereum node if you prefer. We set up an account at [Infura](https://app.infura.io) and created an API key for the Sepolia network. You should do the same and add the API key to your environment variables. This allows us to use a third party's Ethereum node that will handle our requests to and from the blockchain. This is a point of centralization that could be avoided by running your own node.


## Verifying attestations

For now, you can simply drag and drop your offchain `Attestation.txt` file into this [online verifier](https://sepolia.easscan.org/tools) - if the signature is valid it will decoce the attestation and show you the details in the browser.


## Environment variables

Copy the following into your `.env` fiel, replacing the placeholders with your Ethereum private key and Infura API key.

```
NETWORK_NAME: 'sepolia'
REGISTRY_CONTRACT_ADDRESS_SEPOLIA: '0x0a7E2Ff54e76B8E6659aedc9103FB21c038050D0'
EAS_CONTRACT_ADDRESS_SEPOLIA: '0xC2679fBD37d54388Ce493F1DB75320D236e1815e'
ETH_PRIVATE_KEY: <YOUR ETH PRIVATE KEY>
INFURA_API_KEY: < YOUR INFURA API KEY>
SCHEMA_EXPLORER_URL: 'https://sepolia.easscan.org/schema/view/0xaa3f7dd53ef0b3d6f167dea3b4c79e3096e5d21de231993ab15d6b94a40ba699'
SCHEMA_UID: '0x9f074eced91e2c6952fdf5734ec1d8cc05e1e1d07eaa442f07746b7d8a422c0e'
```


## Run command

For an onchain attestation

```
npm run if-attest -- -manifest ./manifests/outputs/example.yaml --blockchain true --level 3 --unit site-visits
```

For an offchain attestation

```
npm run if-attest -- --manifest ./manifests/outputs/example.yaml --blockchain false --level 3 --unit site-visits
```
